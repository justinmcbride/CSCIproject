#!/usr/bin/env python

'''\mainpage Remote Sensing
\section information Information
This program collects data from the hardware sensors, then converts it to a readable unit (Celcius, etc), and uploads it to a server.

We only need one python file to accomplish this, and that file is sensing.py. This single file depends on the pypcduino library however, and that code is also included.

The appropriate documentation is included within.

\section authors Authors
Made by:
- Justin McBride
- Austin Cerny
- Reed Anderson
- Aaron Holt

\section hardwareinfo Hardware Information
This python script runs on several pcDuino v2 boards located in different places.
Each unit has various sensors attached to it, and for whatever sensor they have, the appropriate data is uploaded.

\section serverinfo Server Information
The server is a Ubuntu instance on Amazon's EC2 infrastructure. The server runs MongoDB and listens for input through a REST API generated by a DreamFactory instance. The server also utilizes Angular.JS andNode.JS to create a graphical frontend for the information.

\section requirements Requirements to Run
This code requires the external library 'requests'.
'''

from datetime import datetime
import argparse
import time
import json
import requests
from pypcduino import analog_read

## The ID/tag to identify the individual board, passed as a command-line argument.
boardName = ''
## A global list that will hold the various sensors' instances so that we can poll them later
availableSensors = []
## This is the location of the REST API and it is where we will send our calls to.
apiURI = 'https://dsp-csci-project.cloud.dreamfactory.com:443/rest/mongodb/sensordata'
## These are the headers that we need to send with our REST API calls
headers = {'content-type' : 'application/json', 'X-DreamFactory-Application-Name' : 'RemoteSensing'}

##Put the program to sleep for a specified number of milliseconds
# @param ms The number of milliseconds to sleep for
def delay(ms):
	time.sleep(1.0*ms/1000)

## The Loop
#This is where the program will spend the majority of its time, looping through indefinitely.
def loop():
	i = 0
	while 1:
		i = i + 1
		updatePinReadings()
		if i == 5:
			sensorData = getSensorData()
			sendData(sensorData)
			i = 0
		delay(5000)

##Here we actually ship off the information to the server. This function accepts a dictionary input of the data from the sensors, then inserts that dictionary into a different dictionary that wraps it with the board's identity and the time of the data collection.
# @param sensorData A dictionary of the various sensor types and their values
def sendData(sensorData):
	data = {"boardName" : boardName, "sensorData" : sensorData, "date" : datetime.now().isoformat()}
	try:
		response = requests.post(apiURI, data=json.dumps(data), headers=headers)
	except requests.exceptions.ConnectionError:
		print "Connection error. Skipping current upload"

##This function will read the values reported by the hardware, and then save that data to the appropriate sensor's variable
def updatePinReadings():
	for sensor in availableSensors:
		sensor.update()

def getSensorData():
	sensorData = {}
	for sensor in availableSensors:
		sensorData.update(sensor.getValue())
	return sensorData

##Any sensors that are available will be added to a list that gets polled later for their readings. Any sensor that is not on that specific board should be commented out from this function to prevent garbage values.
def setupSensors():
	global availableSensors
	temperatureSensor = TemperatureSensor()
	availableSensors.append(temperatureSensor)
	lightSensor = LightSensor()
	availableSensors.append(lightSensor)

## The class for a Temperature Sensor
# It has the functions to get the temperature and parse it
class TemperatureSensor(object):
	## The constructor, which sets the name of the sensor for the server and which pin needs to be polled
	def __init__(self, name='Temperature', pin=2):
		if type(name) is not str:
			raise SensorNameException()
		else:
			self._sensorName = name
		if pin <= 0 or pin >= 5:
			raise SensorPinException()
		else:
			self._sensorPin = pin
		self._sensorReading = 0
		self._sensorValue = 0
		self._history = []

	## The reading from the board is not formatted in the correct units, so we first need to find what the millivoltage that the board is reading is.
	# @param self Needed to access the member variables
	def adToVoltage(self):
		voltage = self._sensorReading * 3.3
		voltage /= 4096.0
		return voltage

	## The sensors are not perfect, so we take 5 readings and average them together before using the value
	# @param self Needed to access the member variables
	# @return An average of the last 5 calculated readings
	def getAverageofReadings(self):
		total = 0
		for i in self._history:
			total += i
		del self._history[:]
		return total / 5

	## We need to convert the millivoltage to an actual temperature
	# @param voltage The voltage to convert
	# @return Calculated Fahrenheit temperature from the voltage
	def voltageToTemp(self, voltage):
		celsius = (voltage - 0.5) * 100
		return 9.0 / 5.0 * celsius + 32

	## The method that will read fom the pin, convert it to a value, and store that value
	# @param self Needed to access member variables
	def update(self):
		self._sensorReading = analog_read(self._sensorPin)
		voltage = self.adToVoltage()
		temp = self.voltageToTemp(voltage)
		self._history.append(temp)

	## This will return the sensor's name and value as a dictionary to be appended to a list of other sensors to be polled.
	# @param self Needed to access the member variables
	def getValue(self):
		return {self._sensorName : self.getAverageofReadings()}

	## @var _sensorName
	# A member variable to distinguish which sensor it is
	## @var _sensorReading
	# A member variable to hold the raw ADC reading from the board on the corresponding pi
	## @var _sensorValue
	# A member variable to hold the finalized and formatted value of the pin reading
	## @var _sensorPin
	# A member variable to distinguish which pin should be polled for this sensor
	## @var _history
	# Holds the last few data points to average them out later

## The class for a light sensor
# Contains all the functions to get data about the light
class LightSensor(object):
	# The constructor
	def __init__(self, name='Light', pin=4):
		if type(name) is not str:
			raise SensorNameException()
		else:
			self._sensorName = name
		if pin <= 0 or pin >= 5:
			raise SensorPinException()
		else:
			self._sensorPin = pin
		self._history = []

	## This will return the sensor's name and value as a dictionary to be appended to a list of other sensors to be polled.
	# @param self Needed to access the member variables
	def getValue(self):
		return {self._sensorName : self.getAverageofReadings()}

	## The method that will read fom the pin, convert it to a value, and store that value
	# @param self Needed to access member variables
	def update(self):
		reading = analog_read(self._sensorPin)
		self._history.append(reading)

	## The sensors are not perfect, so we take 5 readings and average them together before using the value
	# @param self Needed to access the member variables
	# @return An average of the last 5 calculated readings
	def getAverageofReadings(self):
		total = 0
		for i in self._history:
			total += i
		del self._history[:]
		return total / 5

	## @var _sensorName
	# A member variable to distinguish which sensor it is
	## @var _sensorPin
	# A member variable to distinguish which pin should be polled for this sensor
	## @var _history
	# Holds the last few data points to average them out later

## An exception to get thrown when a sensor was set up with an invalid pin location
class SensorPinException(Exception):
	pass
## An exception to get thrown when a sensor was set up with an invalid name
class SensorNameException(Exception):
	pass

##The entry point of the program, where we will make a call to setup the various connected sensors, and then begin looping indefinitely to poll those sensors and upload the collected data.
def main():
	global boardName
	parser = argparse.ArgumentParser()
	parser.add_argument('name')
	args = parser.parse_args()
	boardName = args.name
	setupSensors()
	loop()

if __name__ == "__main__":
	main()

