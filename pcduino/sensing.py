#!/usr/bin/env python

'''\mainpage Remote Sensing
\section information Information
This program collects data from the hardware sensors, then converts it to a readable unit (Celcius, etc), and uploads it to a server.

We only need one python file to accomplish this, and that file is sensing.py. This single file depends on the pypcduino library however, and that code is also included.

The appropriate documentation is included within.

\section authors Authors
Made by:
- Justin McBride
- Austin Cerny
- Reed Anderson
- Aaron Holt

\section hardwareinfo Hardware Information
This python script runs on several pcDuino v2 boards located in different places.
Each unit has various sensors attached to it, and for whatever sensor they have, the appropriate data is uploaded.

\section serverinfo Server Information
The server is a Ubuntu instance on Amazon's EC2 infrastructure. The server runs MongoDB and listens for input through a REST API generated by a DreamFactory instance. The server also utilizes Angular.JS andNode.JS to create a graphical frontend for the information.

\section requirements
This code requires the external library 'requests'.
'''

from datetime import datetime
import time
import json
import requests
from pypcduino import analog_read

## A unique board ID to identify the individual board
boardName = 'Justin'
## A global variable to hold the last reading of the last temperature measured
lastTemperature = 0
## A global variable to hold the last reading of the last light brightness measured
lastLight = 0
## A global list that will hold the various sensors' instances so that we can poll them later
availableSensors = []

## This is the location of the REST API and it is where we will send our calls to.
apiURI = 'https://dsp-csci-project.cloud.dreamfactory.com:443/rest/mongodb/sensordata'
## These are the headers that we need to send with our REST API calls
headers = {'content-type' : 'application/json', 'X-DreamFactory-Application-Name' : 'RemoteSensing'}

##Put the program to sleep for a specified number of seconds
def delay(ms):
	time.sleep(1.0*ms/1000)

## The Loop
#This is where the program will spend the majority of its time, looping through indefinitely.
def loop():
	while(1):
		sensorData = updatePinReadings()
		sendData(sensorData)
		delay(5000)

##Here we actually ship off the information to the server. This function accepts a dictionary input of the data from the sensors, then inserts that dictionary into a different dictionary that wraps it with the board's identity and the time of the data collection.
def sendData(sensorData):
	data = {"boardName" : boardName, "sensorData" : sensorData, "date" : datetime.now()}
	response = requests.post(apiURI, data=json.dumps(data, cls=DateTimeEncoder), headers=headers)


##This function will read the values reported by the hardware, and then save that data to the appropriate sensor's variable
def updatePinReadings():
	sensorData = {}
	for sensor in availableSensors:
		sensorData.update(sensor.getValue())
	return sensorData

##Any sensors that are available will be added to a list that gets polled later for their readings. Any sensor that is not on that specific board should be commented out from this function to prevent garbage values.
def setupSensors():
	global availableSensors
	temperatureSensor = TemperatureSensor()
	availableSensors.append(temperatureSensor)
	lightSensor = LightSensor()
	availableSensors.append(lightSensor)

## The class for a Temperature Sensor
# It has the functions to get the temperature and parse it
class TemperatureSensor():
	# The constructor, which sets the name of the sensor for the server and which pin needs to be polled
	def __init__(self):
		self.sensorName = 'Temperature'
		self.sensorValue = 0
		self.sensorPin = 2
		self.sensorReading = 0

	# The reading from the board is not formatted in the correct units, so we first need to find what the millivoltage that the board is reading is.
	def adToVoltage(self):
		voltage = self.sensorReading * 5.0
		voltage /= 1024.0
		self.sensorReading = voltage

	# This will return the sensor's name and value as a dictionary to be appended to a list of other sensors to be polled.
	def getValue(self):
		self.sensorReading = analog_read(self.sensorPin)
		self.adToVoltage()
		self.sensorValue = (self.sensorReading - 0.5) * (100 / 17.43)
		return { self.sensorName : self.sensorValue }

## The class for a light sensor
# Contains all the functions to get data about the light
class LightSensor():
	# The constructor
	def __init__(self):
		self.sensorName = 'Light'
		self.sensorReading = 0
		self.sensorValue = 0
		self.sensorPin = 4

	# This will return the sensor's name and value as a dictionary to be appended to a list of other sensors to be polled.
	def getValue(self):
		self.sensorReading = analog_read(self.sensorPin)
		self.sensorValue = self.sensorReading
		return { self.sensorName : self.sensorValue }

## This is a class to allow the timestamp to be JSON serializable
# Without this, the JSON module would complain about the date
class DateTimeEncoder(json.JSONEncoder):
	def default(self, obj):
		if isinstance(obj, datetime):
			encoded_object = list(obj.timetuple())[0:6]
		else:
			encoded_object =json.JSONEncoder.default(self, obj)
		return encoded_object

##The entry point of the program, where we will make a call to setup the various connected sensors, and then begin looping indefinitely to poll those sensors and upload the collected data.
def main():
	setupSensors()
	loop()

if __name__ == "__main__":
	main()


