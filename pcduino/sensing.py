#!/usr/bin/env python

'''\mainpage Remote Sensing
\section information Information
This program collects data from the hardware sensors, then converts it to a readable unit (Celcius, etc), and uploads it to a server.

We only need one python file to accomplish this, and that file is sensing.py. This single file depends on the pypcduino library however, and that code is also included.

The appropriate documentation is included within.

\section authors Authors
Made by:
- Justin McBride
- Austin Cerny
- Reed Anderson
- Aaron Holt

\section hardwareinfo Hardware Information
This python script runs on several pcDuino v2 boards located in different places.
Each unit has various sensors attached to it, and for whatever sensor they have, the appropriate data is uploaded.

\section serverinfo Server Information
The server is a Ubuntu instance on Amazon's EC2 infrastructure. The server runs MongoDB and listens for input through a REST API generated by a DreamFactory instance. The server also utilizes Angular.JS andNode.JS to create a graphical frontend for the information.

\section requirements Requirements to Run
This code requires the external library 'requests'.
'''

from datetime import datetime
import argparse
import time
import json
import requests
from pypcduino import analog_read

## The ID/tag to identify the individual board, passed as a command-line argument.
boardName = ''
## A global list that will hold the various sensors' instances so that we can poll them later
availableSensors = []
## This is the location of the REST API and it is where we will send our calls to.
apiURI = 'https://dsp-csci-project.cloud.dreamfactory.com:443/rest/mongodb/sensordata'
## These are the headers that we need to send with our REST API calls
headers = {'content-type' : 'application/json', 'X-DreamFactory-Application-Name' : 'RemoteSensing'}

##Put the program to sleep for a specified number of milliseconds
# @param ms The number of milliseconds to sleep for
def delay(ms):
	time.sleep(1.0*ms/1000)

## The Loop
#This is where the program will spend the majority of its time, looping through indefinitely.
def loop():
	while(1):
		sensorData = updatePinReadings()
		sendData(sensorData)
		delay(5000)

##Here we actually ship off the information to the server. This function accepts a dictionary input of the data from the sensors, then inserts that dictionary into a different dictionary that wraps it with the board's identity and the time of the data collection.
# @param sensorData A dictionary of the various sensor types and their values
def sendData(sensorData):
	data = {"boardName" : boardName, "sensorData" : sensorData, "date" : datetime.now()}
	response = requests.post(apiURI, data=json.dumps(data, cls=DateTimeEncoder), headers=headers)

##This function will read the values reported by the hardware, and then save that data to the appropriate sensor's variable
def updatePinReadings():
	sensorData = {}
	for sensor in availableSensors:
		sensorData.update(sensor.getValue())
	print 'Data Readings:'
	print sensorData
	return sensorData

##Any sensors that are available will be added to a list that gets polled later for their readings. Any sensor that is not on that specific board should be commented out from this function to prevent garbage values.
def setupSensors():
	global availableSensors
	temperatureSensor = TemperatureSensor()
	availableSensors.append(temperatureSensor)
	lightSensor = LightSensor()
	availableSensors.append(lightSensor)

## The class for a Temperature Sensor
# It has the functions to get the temperature and parse it
class TemperatureSensor():
	## The constructor, which sets the name of the sensor for the server and which pin needs to be polled
	def __init__(self, name='Temperature', pin=2):
		if type(name) is not str:
			raise SensorNameException()
		else:
			self._sensorName = name
		if pin <= 0 or pin >= 5:
			raise SensorPinException()
		else:
			self._sensorPin = pin

	## The reading from the board is not formatted in the correct units, so we first need to find what the millivoltage that the board is reading is.
	# @param self Needed to access the member variables
	def adToVoltage(self):
		voltage = self._sensorReading * 3.3
		voltage /= 4096.0
		self._sensorReading = voltage

	## We need to convert the millivoltage to an actual temperature
	# @param self Needed to access the member variables
	def voltageToTemp(self):
		celsius = (self._sensorReading - 0.5) * 100
		self._sensorValue = 9.0 / 5.0 * celsius + 32

	## This will return the sensor's name and value as a dictionary to be appended to a list of other sensors to be polled.
	# @param self Needed to access the member variables
	def getValue(self):
		self._sensorReading = analog_read(self._sensorPin)
		self.adToVoltage()
		self.voltageToTemp()
		return { self._sensorName : self._sensorValue }

	## @var _sensorName
	# A member variable to distinguish which sensor it is
	## @var _sensorReading
	# A member variable to hold the raw ADC reading from the board on the corresponding pi
	## @var _sensorValue
	# A member variable to hold the finalized and formatted value of the pin reading
	## @var _sensorPin
	# A member variable to distinguish which pin should be polled for this sensor

class SensorPinException(Exception):
	pass
class SensorNameException(Exception):
	pass

## The class for a light sensor
# Contains all the functions to get data about the light
class LightSensor():
	# The constructor
	def __init__(self, name='Light', pin=4):
		if type(name) is not str:
			raise SensorNameException()
		else:
			self._sensorName = name
		if pin <= 0 or pin >= 5:
			raise SensorPinException()
		else:
			self._sensorPin = pin
		self._sensorReading = 0
		self._sensorValue = 0

	## This will return the sensor's name and value as a dictionary to be appended to a list of other sensors to be polled.
	# @param self Needed to access the member variables
	def getValue(self):
		self._sensorReading = analog_read(self._sensorPin)
		self._sensorValue = self._sensorReading
		return { self._sensorName : self._sensorValue }

	## @var _sensorName
	# A member variable to distinguish which sensor it is
	## @var _sensorReading
	# A member variable to hold the raw ADC reading from the board on the corresponding pi
	## @var _sensorValue
	# A member variable to hold the finalized and formatted value of the pin reading
	## @var _sensorPin
	# A member variable to distinguish which pin should be polled for this sensor

## This is a class to allow the timestamp to be JSON serializable
# Without this, the JSON module would complain about the date
class DateTimeEncoder(json.JSONEncoder):
	## The actual function that will be used to serialize the data
	# @param self Needed to access the member variables
	# @param obj The actual object that we want to serialize into JSON
	def default(self, obj):
		if isinstance(obj, datetime):
			encoded_object = list(obj.timetuple())[0:6]
		else:
			encoded_object =json.JSONEncoder.default(self, obj)
		return encoded_object

##The entry point of the program, where we will make a call to setup the various connected sensors, and then begin looping indefinitely to poll those sensors and upload the collected data.
# @param argv Requires a -n or --name command token with the name of the board
def main():
	global boardName
	parser = argparse.ArgumentParser()
	parser.add_argument('name')
	args = parser.parse_args()
	boardName = args.name
	setupSensors()
	loop()

if __name__ == "__main__":
	main()