#!/usr/bin/env python

'''\mainpage Remote Sensing
\section information Information
This program collects data from the hardware sensors, then converts it to a readable unit (Celsius, etc), and uploads it to a server.

We only need one python file to accomplish this, and that file is sensing.py. This single file depends on the pypcduino library however, and that code is also included.

The appropriate documentation is included within.

\section authors Authors
Made by:
- Justin McBride
- Austin Cerny
- Reed Anderson
- Aaron Holt

\section hardwareinfo Hardware Information
This python script runs on several pcDuino v2 boards located in different places.

Each unit has various sensors attached to it, and for whatever sensor they have, the appropriate data is uploaded.

\section serverinfo Server Information
The server is a Ubuntu instance on Amazon's EC2 infrastructure. The server runs MongoDB and listens for input through a REST API generated by a DreamFactory instance. The server also utilizes Angular.JS to create a graphical frontend for the information.

\section requirements Requirements to Run
This code requires the external library 'requests'.

\section testing Testing
Unit testing is enabled through the python unittest module.

To run the tests, simply use the terminal command 

$ python test_sensing.py

\section static Static Analysis
This code utilizes the pylint module to perform static analysis on the code. Simply run

$ pylint sensing.py 

to generate a report. A generated pylintrc directive file is included with the code to supress the following error messages:

*missing-docstring* - Doxygen uses a different format than docstrings for documentation.

*invalid-name* - We're not following PyLint's Style guide.

*mixed-indentation* - Using spaces in Doxygen documentation confuses PyLint

*anomalous-backslash-in-string* - Doxygen uses backslashes in the documentation markdown.

*trailing-whitespace* - Also used in Doxygen formatting.

\section documents Documentation
The documentation for this code was created with the use of Doxygen. Because Doxygen does not natively (at least completely) support Python, the use of Doxypy from http://code.foosel.org/doxypy is used as an input filter.
'''

from datetime import datetime
import argparse
import time
import json
import requests
from pypcduino import analog_read
from pcpcduino import InvalidChannelException

## The ID/tag to identify the individual board, passed as a command-line argument.
boardName = ''
## A global list that will hold the various sensors' instances so that we can poll them later
availableSensors = []
## This is the location of the REST API and it is where we will send our calls to.
apiURI = 'https://dsp-csci-project.cloud.dreamfactory.com:443/rest/mongodb/sensordata'
## These are the headers that we need to send with our REST API calls
headers = {'content-type' : 'application/json', 'X-DreamFactory-Application-Name' : 'RemoteSensing'}

## Put the program to sleep for a specified number of milliseconds
# @param ms The number of milliseconds to sleep for
def delay(ms):
	time.sleep(1.0*ms/1000)

## The main loop 
# This is where the program will spend the majority of its time, looping through indefinitely.
def loop():
	i = 0
	while 1:
		i = i + 1
		updatePinReadings()
		if i == 5:
			sensorData = getSensorData()
			sendData(sensorData)
			i = 0
		delay(5000)

## Here we actually ship off the information to the server. This function accepts a dictionary input of the data from the sensors, then inserts that dictionary into a different dictionary that wraps it with the board's identity and the time of the data collection.
# @param sensorData A dictionary of the various sensor types and their values
# @return Returns true on successful upload, and false otherwise
def sendData(sensorData):
	data = {"boardName" : boardName, "sensorData" : sensorData, "date" : datetime.now().isoformat()}
	try:
		response = requests.post(apiURI, data=json.dumps(data), headers=headers)
		return True
	except requests.exceptions.ConnectionError:
		print "Connection error. Skipping current upload"
		return False

## This function will read the values reported by the hardware, and then save that data to the appropriate sensor's variable
def updatePinReadings():
	for sensor in availableSensors:
		sensor.update()

## This function will retrieve the averaged values from the sensors and format it into a dictionary
# @return A dictionary containing key:value pairs of the sensor's name/type and its averaged value
def getSensorData():
	sensorData = {}
	for sensor in availableSensors:
		sensorData.update(sensor.getValue())
	return sensorData

##Any sensors that are available will be added to a list that gets polled later for their readings. Any sensor that is not on that specific board should be commented out from this function to prevent garbage values.
def setupSensors():
	global availableSensors
	temperatureSensor = TemperatureSensor()
	lightSensor = LightSensor()
	try:
		temperatureSensor.update()
		lightSensor.update()
	except InvalidChannelException:
		raise NoPinFilesException()
	availableSensors.append(temperatureSensor)
	availableSensors.append(lightSensor)

## The class for a Temperature Sensor
# It has the functions to get the temperature and parse it
class TemperatureSensor(object):
	## The constructor, which sets the name of the sensor for the server and which pin needs to be polled
	# @param name Optional. The name of the sensor. Defaults to "Temperature"
	# @param pin Optional. The pin that the sensor connects through. Defaults to pin 2
	def __init__(self, name='Temperature', pin=2):
		if type(name) is not str:
			raise SensorNameException()
		else:
			self._sensorName = name
		if pin <= 0 or pin >= 5:
			raise SensorPinException()
		else:
			self._sensorPin = pin
		self._sensorReading = 0
		self._history = []

	## The reading from the board is not formatted in the correct units, so we first need to find what the millivoltage that the board is reading is.
	def adToVoltage(self):
		voltage = self._sensorReading * 3.3
		voltage /= 4096.0
		return voltage

	## The sensors are not perfect, so we take 5 readings and average them together before using the value
	# @return An average of the last 5 calculated readings
	def getAverageofReadings(self):
		total = 0
		count = 0
		for i in self._history:
			total += i
			count = count + 1
		del self._history[:]
		if count == 0:
			raise NoHistoryException
		return total / count

	## We need to convert the millivoltage to an actual temperature
	# @param voltage The voltage to convert
	# @return Calculated Fahrenheit temperature from the voltage
	def voltageToTemp(self, voltage):
		celsius = (voltage - 0.5) * 100
		return 9.0 / 5.0 * celsius + 32

	## The method that will read fom the pin, convert it to a value, and store that value
	# @exception PinReadOutofRangeException Will be thrown when the reading we get is out of the acceptable range
	def update(self):
		self._sensorReading = analog_read(self._sensorPin)
		if self._sensorReading > 4096 or self._sensorReading < 0:
			raise PinReadOutOfRangeException
		voltage = self.adToVoltage()
		temp = self.voltageToTemp(voltage)
		self._history.append(temp)

	## This will return the sensor's name and value as a dictionary to be appended to a list of other sensors to be polled.
	# @return Returns a key-value pair of the sensor's name in addition to the averaged value read.
	def getValue(self):
		return {self._sensorName : self.getAverageofReadings()}

	## @var _sensorName
	# A member variable to distinguish which sensor it is
	## @var _sensorReading
	# A member variable to hold the raw ADC reading from the board on the corresponding pi
	## @var _sensorPin
	# A member variable to distinguish which pin should be polled for this sensor
	## @var _history
	# Holds the last few data points to average them out later

## The class for a light sensor
# Contains all the functions to get data about the light
class LightSensor(object):
	## Constructor
	# @param name Optional. The name of the sensor. Defaults to "Temperature"
	# @param pin Optional. The pin that the sensor connects through. Defaults to pin 2
	def __init__(self, name='Light', pin=4):
		if type(name) is not str:
			raise SensorNameException()
		else:
			self._sensorName = name
		if pin <= 0 or pin >= 5:
			raise SensorPinException()
		else:
			self._sensorPin = pin
		self._history = []

	## This will return the sensor's name and value as a dictionary to be appended to a list of other sensors to be polled.
	# @return Returns a key-value pair of the sensor's name in addition to the averaged value read.
	def getValue(self):
		return {self._sensorName : self.brightness(self.getAverageofReadings())}

	## The method that will read fom the pin, convert it to a value, and store that values
	def update(self):
		reading = analog_read(self._sensorPin)
		if reading > 4096 or reading < 0:
			raise PinReadOutOfRangeException
		self._history.append(reading)

	## Because the light sensor does not truly give a readable value, we convert it to  a percentage of 100.
	# @param value The number between 0 and 4096 to convert to a percentage
	# @return Will return the brightness as a percentage value
	def brightness(self, value):
		return (value / 4096.0) * 100.0

	## The sensors are not perfect, so we take 5 readings and average them together before using the value
	# @return An average of the last 5 calculated readings
	def getAverageofReadings(self):
		total = 0
		count = 0
		for i in self._history:
			total += i
			count = count + 1
		del self._history[:]
		if count == 0:
			raise NoHistoryException
		return total / count

	## @var _sensorName
	# A member variable to distinguish which sensor it is
	## @var _sensorPin
	# A member variable to distinguish which pin should be polled for this sensor
	## @var _history
	# Holds the last few data points to average them out later

## An exception to get thrown when a sensor was set up with an invalid pin location
class SensorPinException(Exception):
	pass
## An exception to get thrown when a sensor was set up with an invalid name
class SensorNameException(Exception):
	pass
## An exception that would be raised when a sensor's history list is empty
class NoHistoryException(Exception):
	pass
## An exception that should occur when a pin reads out of range (0-4096)
class PinReadOutOfRangeException(Exception):
	pass

## An exception when there is no place to read Pin values from, meaning that the code is not being run on the appropriate hardware
class NoPinFilesException(Exception):
	pass

##The entry point of the program, where we will make a call to setup the various connected sensors, and then begin looping indefinitely to poll those sensors and upload the collected data.
def main():
	global boardName
	parser = argparse.ArgumentParser()
	parser.add_argument('name')
	args = parser.parse_args()
	boardName = args.name
	setupSensors()
	loop()

if __name__ == "__main__":
	main()

